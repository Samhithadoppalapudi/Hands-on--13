# -*- coding: utf-8 -*-
"""Hands- on 13 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10cMtF4hAPEwWMzi7HXm1wseKo_7gudZW
"""

# Topological Sort

from collections import defaultdict

def topological_sort(vertices, edges):
    graph = defaultdict(list)
    for src, dest in edges:
        graph[src].append(dest)

    visited = [False] * vertices
    stack = []

    def dfs(v):
        visited[v] = True
        for neighbor in graph[v]:
            if not visited[neighbor]:
                dfs(neighbor)
        stack.append(v)

    for i in range(vertices):
        if not visited[i]:
            dfs(i)

    print("Topological order:", stack[::-1])

# Example
vertices = 4
edges = [(0, 1), (0, 2), (1, 3), (2, 3)]
topological_sort(vertices, edges)

# Depth-First Search
from collections import defaultdict

def depth_first_search(vertices, edges):
    graph = defaultdict(list)
    for src, dest in edges:
        graph[src].append(dest)

    visited = [False] * vertices

    def dfs(v):
        visited[v] = True
        print(v, end=" ")
        for neighbor in graph[v]:
            if not visited[neighbor]:
                dfs(neighbor)

    print("DFS traversal:", end=" ")
    for i in range(vertices):
        if not visited[i]:
            dfs(i)
    print()

# Example
vertices = 4
edges = [(0, 1), (0, 2), (1, 3), (2, 3)]
depth_first_search(vertices, edges)

# Kruskal algorithm
class Edge:
    def __init__(self, src, dest, weight):
        self.src = src
        self.dest = dest
        self.weight = weight

def find_parent(v, parent):
    if parent[v] != v:
        parent[v] = find_parent(parent[v], parent)
    return parent[v]

def union_sets(u, v, parent, rank):
    root_u = find_parent(u, parent)
    root_v = find_parent(v, parent)

    if root_u != root_v:
        if rank[root_u] > rank[root_v]:
            parent[root_v] = root_u
        elif rank[root_u] < rank[root_v]:
            parent[root_u] = root_v
        else:
            parent[root_v] = root_u
            rank[root_u] += 1

def kruskal_mst(vertices, edges):
    edges.sort(key=lambda edge: edge.weight)

    parent = list(range(vertices))
    rank = [0] * vertices

    mst = []
    mst_weight = 0

    for edge in edges:
        if find_parent(edge.src, parent) != find_parent(edge.dest, parent):
            mst.append(edge)
            mst_weight += edge.weight
            union_sets(edge.src, edge.dest, parent, rank)

    print("Edges in MST:")
    for edge in mst:
        print(f"{edge.src} -- {edge.dest} == {edge.weight}")
    print("Total weight:", mst_weight)

# Example
edges = [
    Edge(0, 1, 10), Edge(0, 2, 6), Edge(0, 3, 5),
    Edge(1, 3, 15), Edge(2, 3, 4)
]
vertices = 4
kruskal_mst(vertices, edges)